// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.1
//   Build date: 2016-04-08 17:16:44 UTC
//   on: 2016-04-28, 20:31:57 UTC
//   C++ generator version: 0.1.4

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   Drive API (drive/v3)
// Generated from:
//   Version: v3
//   Revision: 22
// Generated by:
//    Tool: google-apis-code-generator 1.5.1
//     C++: 0.1.4
#ifndef  GOOGLE_DRIVE_API_FILE_H_
#define  GOOGLE_DRIVE_API_FILE_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/client/util/date_time.h"
#include "googleapis/strings/stringpiece.h"

#include "google/drive_api/permission.h"
#include "google/drive_api/user.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_drive_api {
using namespace googleapis;

/**
 * The metadata for a file.
 *
 * @ingroup DataObject
 */
class File : public client::JsonCppData {
 public:
  /**
   * Capabilities the current user has on the file.
   *
   * @ingroup DataObject
   */
  class FileCapabilities : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileCapabilities* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileCapabilities(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileCapabilities(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileCapabilities();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileCapabilities</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileCapabilities");
    }

    /**
     * Determine if the '<code>canComment</code>' attribute was set.
     *
     * @return true if the '<code>canComment</code>' attribute was set.
     */
    bool has_can_comment() const {
      return Storage().isMember("canComment");
    }

    /**
     * Clears the '<code>canComment</code>' attribute.
     */
    void clear_can_comment() {
      MutableStorage()->removeMember("canComment");
    }


    /**
     * Get the value of the '<code>canComment</code>' attribute.
     */
    bool get_can_comment() const {
      const Json::Value& storage = Storage("canComment");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>canComment</code>' attribute.
     *
     * Whether the user can comment on the file.
     *
     * @param[in] value The new value.
     */
    void set_can_comment(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("canComment"));
    }

    /**
     * Determine if the '<code>canCopy</code>' attribute was set.
     *
     * @return true if the '<code>canCopy</code>' attribute was set.
     */
    bool has_can_copy() const {
      return Storage().isMember("canCopy");
    }

    /**
     * Clears the '<code>canCopy</code>' attribute.
     */
    void clear_can_copy() {
      MutableStorage()->removeMember("canCopy");
    }


    /**
     * Get the value of the '<code>canCopy</code>' attribute.
     */
    bool get_can_copy() const {
      const Json::Value& storage = Storage("canCopy");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>canCopy</code>' attribute.
     *
     * Whether the user can copy the file.
     *
     * @param[in] value The new value.
     */
    void set_can_copy(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("canCopy"));
    }

    /**
     * Determine if the '<code>canEdit</code>' attribute was set.
     *
     * @return true if the '<code>canEdit</code>' attribute was set.
     */
    bool has_can_edit() const {
      return Storage().isMember("canEdit");
    }

    /**
     * Clears the '<code>canEdit</code>' attribute.
     */
    void clear_can_edit() {
      MutableStorage()->removeMember("canEdit");
    }


    /**
     * Get the value of the '<code>canEdit</code>' attribute.
     */
    bool get_can_edit() const {
      const Json::Value& storage = Storage("canEdit");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>canEdit</code>' attribute.
     *
     * Whether the user can edit the file's content.
     *
     * @param[in] value The new value.
     */
    void set_can_edit(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("canEdit"));
    }

    /**
     * Determine if the '<code>canReadRevisions</code>' attribute was set.
     *
     * @return true if the '<code>canReadRevisions</code>' attribute was set.
     */
    bool has_can_read_revisions() const {
      return Storage().isMember("canReadRevisions");
    }

    /**
     * Clears the '<code>canReadRevisions</code>' attribute.
     */
    void clear_can_read_revisions() {
      MutableStorage()->removeMember("canReadRevisions");
    }


    /**
     * Get the value of the '<code>canReadRevisions</code>' attribute.
     */
    bool get_can_read_revisions() const {
      const Json::Value& storage = Storage("canReadRevisions");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>canReadRevisions</code>' attribute.
     *
     * Whether the current user has read access to the Revisions resource of the
     * file.
     *
     * @param[in] value The new value.
     */
    void set_can_read_revisions(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("canReadRevisions"));
    }

    /**
     * Determine if the '<code>canShare</code>' attribute was set.
     *
     * @return true if the '<code>canShare</code>' attribute was set.
     */
    bool has_can_share() const {
      return Storage().isMember("canShare");
    }

    /**
     * Clears the '<code>canShare</code>' attribute.
     */
    void clear_can_share() {
      MutableStorage()->removeMember("canShare");
    }


    /**
     * Get the value of the '<code>canShare</code>' attribute.
     */
    bool get_can_share() const {
      const Json::Value& storage = Storage("canShare");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>canShare</code>' attribute.
     *
     * Whether the user can modify the file's permissions and sharing settings.
     *
     * @param[in] value The new value.
     */
    void set_can_share(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("canShare"));
    }

   private:
    void operator=(const FileCapabilities&);
  };  // FileCapabilities
  /**
   * Additional information about the content of the file. These fields are
   * never populated in responses.
   *
   * @ingroup DataObject
   */
  class FileContentHints : public client::JsonCppData {
   public:
    /**
     * A thumbnail for the file. This will only be used if Drive cannot generate
     * a standard thumbnail.
     *
     * @ingroup DataObject
     */
    class FileContentHintsThumbnail : public client::JsonCppData {
     public:
      /**
       * Creates a new default instance.
       *
       * @return Ownership is passed back to the caller.
       */
      static FileContentHintsThumbnail* New();

      /**
       * Standard constructor for an immutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileContentHintsThumbnail(const Json::Value& storage);

      /**
       * Standard constructor for a mutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileContentHintsThumbnail(Json::Value* storage);

      /**
       * Standard destructor.
       */
      virtual ~FileContentHintsThumbnail();

      /**
       * Returns a string denoting the type of this data object.
       *
       * @return <code>google_drive_api::FileContentHintsThumbnail</code>
       */
      const StringPiece GetTypeName() const {
        return StringPiece("google_drive_api::FileContentHintsThumbnail");
      }

      /**
       * Determine if the '<code>image</code>' attribute was set.
       *
       * @return true if the '<code>image</code>' attribute was set.
       */
      bool has_image() const {
        return Storage().isMember("image");
      }

      /**
       * Clears the '<code>image</code>' attribute.
       */
      void clear_image() {
        MutableStorage()->removeMember("image");
      }


      /**
       * Get the value of the '<code>image</code>' attribute.
       */
      const StringPiece get_image() const {
        const Json::Value& v = Storage("image");
        if (v == Json::Value::null) return StringPiece("");
        return StringPiece(v.asCString());
      }

      /**
       * Change the '<code>image</code>' attribute.
       *
       * The thumbnail data encoded with URL-safe Base64 (RFC 4648 section 5).
       *
       * @param[in] value The new value.
       */
      void set_image(const StringPiece& value) {
        *MutableStorage("image") = value.data();
      }

      /**
       * Determine if the '<code>mimeType</code>' attribute was set.
       *
       * @return true if the '<code>mimeType</code>' attribute was set.
       */
      bool has_mime_type() const {
        return Storage().isMember("mimeType");
      }

      /**
       * Clears the '<code>mimeType</code>' attribute.
       */
      void clear_mime_type() {
        MutableStorage()->removeMember("mimeType");
      }


      /**
       * Get the value of the '<code>mimeType</code>' attribute.
       */
      const StringPiece get_mime_type() const {
        const Json::Value& v = Storage("mimeType");
        if (v == Json::Value::null) return StringPiece("");
        return StringPiece(v.asCString());
      }

      /**
       * Change the '<code>mimeType</code>' attribute.
       *
       * The MIME type of the thumbnail.
       *
       * @param[in] value The new value.
       */
      void set_mime_type(const StringPiece& value) {
        *MutableStorage("mimeType") = value.data();
      }

     private:
      void operator=(const FileContentHintsThumbnail&);
    };  // FileContentHintsThumbnail
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileContentHints* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileContentHints(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileContentHints(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileContentHints();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileContentHints</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileContentHints");
    }

    /**
     * Determine if the '<code>indexableText</code>' attribute was set.
     *
     * @return true if the '<code>indexableText</code>' attribute was set.
     */
    bool has_indexable_text() const {
      return Storage().isMember("indexableText");
    }

    /**
     * Clears the '<code>indexableText</code>' attribute.
     */
    void clear_indexable_text() {
      MutableStorage()->removeMember("indexableText");
    }


    /**
     * Get the value of the '<code>indexableText</code>' attribute.
     */
    const StringPiece get_indexable_text() const {
      const Json::Value& v = Storage("indexableText");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>indexableText</code>' attribute.
     *
     * Text to be indexed for the file to improve fullText queries. This is
     * limited to 128KB in length and may contain HTML elements.
     *
     * @param[in] value The new value.
     */
    void set_indexable_text(const StringPiece& value) {
      *MutableStorage("indexableText") = value.data();
    }

    /**
     * Determine if the '<code>thumbnail</code>' attribute was set.
     *
     * @return true if the '<code>thumbnail</code>' attribute was set.
     */
    bool has_thumbnail() const {
      return Storage().isMember("thumbnail");
    }

    /**
     * Clears the '<code>thumbnail</code>' attribute.
     */
    void clear_thumbnail() {
      MutableStorage()->removeMember("thumbnail");
    }


    /**
     * Get a reference to the value of the '<code>thumbnail</code>' attribute.
     */
    const FileContentHintsThumbnail get_thumbnail() const {
       const Json::Value& storage = Storage("thumbnail");
      return client::JsonValueToCppValueHelper<FileContentHintsThumbnail >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>thumbnail</code>'
     * property.
     *
     * A thumbnail for the file. This will only be used if Drive cannot generate
     * a standard thumbnail.
     *
     * @return The result can be modified to change the attribute value.
     */
    FileContentHintsThumbnail mutable_thumbnail() {
      Json::Value* storage = MutableStorage("thumbnail");
      return client::JsonValueToMutableCppValueHelper<FileContentHintsThumbnail >(storage);
    }

   private:
    void operator=(const FileContentHints&);
  };  // FileContentHints
  /**
   * Additional metadata about image media, if available.
   *
   * @ingroup DataObject
   */
  class FileImageMediaMetadata : public client::JsonCppData {
   public:
    /**
     * Geographic location information stored in the image.
     *
     * @ingroup DataObject
     */
    class FileImageMediaMetadataLocation : public client::JsonCppData {
     public:
      /**
       * Creates a new default instance.
       *
       * @return Ownership is passed back to the caller.
       */
      static FileImageMediaMetadataLocation* New();

      /**
       * Standard constructor for an immutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileImageMediaMetadataLocation(const Json::Value& storage);

      /**
       * Standard constructor for a mutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileImageMediaMetadataLocation(Json::Value* storage);

      /**
       * Standard destructor.
       */
      virtual ~FileImageMediaMetadataLocation();

      /**
       * Returns a string denoting the type of this data object.
       *
       * @return <code>google_drive_api::FileImageMediaMetadataLocation</code>
       */
      const StringPiece GetTypeName() const {
        return StringPiece("google_drive_api::FileImageMediaMetadataLocation");
      }

      /**
       * Determine if the '<code>altitude</code>' attribute was set.
       *
       * @return true if the '<code>altitude</code>' attribute was set.
       */
      bool has_altitude() const {
        return Storage().isMember("altitude");
      }

      /**
       * Clears the '<code>altitude</code>' attribute.
       */
      void clear_altitude() {
        MutableStorage()->removeMember("altitude");
      }


      /**
       * Get the value of the '<code>altitude</code>' attribute.
       */
      double get_altitude() const {
        const Json::Value& storage = Storage("altitude");
        return client::JsonValueToCppValueHelper<double >(storage);
      }

      /**
       * Change the '<code>altitude</code>' attribute.
       *
       * The altitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_altitude(double value) {
        client::SetJsonValueFromCppValueHelper<double >(
          value, MutableStorage("altitude"));
      }

      /**
       * Determine if the '<code>latitude</code>' attribute was set.
       *
       * @return true if the '<code>latitude</code>' attribute was set.
       */
      bool has_latitude() const {
        return Storage().isMember("latitude");
      }

      /**
       * Clears the '<code>latitude</code>' attribute.
       */
      void clear_latitude() {
        MutableStorage()->removeMember("latitude");
      }


      /**
       * Get the value of the '<code>latitude</code>' attribute.
       */
      double get_latitude() const {
        const Json::Value& storage = Storage("latitude");
        return client::JsonValueToCppValueHelper<double >(storage);
      }

      /**
       * Change the '<code>latitude</code>' attribute.
       *
       * The latitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_latitude(double value) {
        client::SetJsonValueFromCppValueHelper<double >(
          value, MutableStorage("latitude"));
      }

      /**
       * Determine if the '<code>longitude</code>' attribute was set.
       *
       * @return true if the '<code>longitude</code>' attribute was set.
       */
      bool has_longitude() const {
        return Storage().isMember("longitude");
      }

      /**
       * Clears the '<code>longitude</code>' attribute.
       */
      void clear_longitude() {
        MutableStorage()->removeMember("longitude");
      }


      /**
       * Get the value of the '<code>longitude</code>' attribute.
       */
      double get_longitude() const {
        const Json::Value& storage = Storage("longitude");
        return client::JsonValueToCppValueHelper<double >(storage);
      }

      /**
       * Change the '<code>longitude</code>' attribute.
       *
       * The longitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_longitude(double value) {
        client::SetJsonValueFromCppValueHelper<double >(
          value, MutableStorage("longitude"));
      }

     private:
      void operator=(const FileImageMediaMetadataLocation&);
    };  // FileImageMediaMetadataLocation
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileImageMediaMetadata* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileImageMediaMetadata(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileImageMediaMetadata(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileImageMediaMetadata();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileImageMediaMetadata</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileImageMediaMetadata");
    }

    /**
     * Determine if the '<code>aperture</code>' attribute was set.
     *
     * @return true if the '<code>aperture</code>' attribute was set.
     */
    bool has_aperture() const {
      return Storage().isMember("aperture");
    }

    /**
     * Clears the '<code>aperture</code>' attribute.
     */
    void clear_aperture() {
      MutableStorage()->removeMember("aperture");
    }


    /**
     * Get the value of the '<code>aperture</code>' attribute.
     */
    float get_aperture() const {
      const Json::Value& storage = Storage("aperture");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>aperture</code>' attribute.
     *
     * The aperture used to create the photo (f-number).
     *
     * @param[in] value The new value.
     */
    void set_aperture(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("aperture"));
    }

    /**
     * Determine if the '<code>cameraMake</code>' attribute was set.
     *
     * @return true if the '<code>cameraMake</code>' attribute was set.
     */
    bool has_camera_make() const {
      return Storage().isMember("cameraMake");
    }

    /**
     * Clears the '<code>cameraMake</code>' attribute.
     */
    void clear_camera_make() {
      MutableStorage()->removeMember("cameraMake");
    }


    /**
     * Get the value of the '<code>cameraMake</code>' attribute.
     */
    const StringPiece get_camera_make() const {
      const Json::Value& v = Storage("cameraMake");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>cameraMake</code>' attribute.
     *
     * The make of the camera used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_camera_make(const StringPiece& value) {
      *MutableStorage("cameraMake") = value.data();
    }

    /**
     * Determine if the '<code>cameraModel</code>' attribute was set.
     *
     * @return true if the '<code>cameraModel</code>' attribute was set.
     */
    bool has_camera_model() const {
      return Storage().isMember("cameraModel");
    }

    /**
     * Clears the '<code>cameraModel</code>' attribute.
     */
    void clear_camera_model() {
      MutableStorage()->removeMember("cameraModel");
    }


    /**
     * Get the value of the '<code>cameraModel</code>' attribute.
     */
    const StringPiece get_camera_model() const {
      const Json::Value& v = Storage("cameraModel");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>cameraModel</code>' attribute.
     *
     * The model of the camera used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_camera_model(const StringPiece& value) {
      *MutableStorage("cameraModel") = value.data();
    }

    /**
     * Determine if the '<code>colorSpace</code>' attribute was set.
     *
     * @return true if the '<code>colorSpace</code>' attribute was set.
     */
    bool has_color_space() const {
      return Storage().isMember("colorSpace");
    }

    /**
     * Clears the '<code>colorSpace</code>' attribute.
     */
    void clear_color_space() {
      MutableStorage()->removeMember("colorSpace");
    }


    /**
     * Get the value of the '<code>colorSpace</code>' attribute.
     */
    const StringPiece get_color_space() const {
      const Json::Value& v = Storage("colorSpace");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>colorSpace</code>' attribute.
     *
     * The color space of the photo.
     *
     * @param[in] value The new value.
     */
    void set_color_space(const StringPiece& value) {
      *MutableStorage("colorSpace") = value.data();
    }

    /**
     * Determine if the '<code>exposureBias</code>' attribute was set.
     *
     * @return true if the '<code>exposureBias</code>' attribute was set.
     */
    bool has_exposure_bias() const {
      return Storage().isMember("exposureBias");
    }

    /**
     * Clears the '<code>exposureBias</code>' attribute.
     */
    void clear_exposure_bias() {
      MutableStorage()->removeMember("exposureBias");
    }


    /**
     * Get the value of the '<code>exposureBias</code>' attribute.
     */
    float get_exposure_bias() const {
      const Json::Value& storage = Storage("exposureBias");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>exposureBias</code>' attribute.
     *
     * The exposure bias of the photo (APEX value).
     *
     * @param[in] value The new value.
     */
    void set_exposure_bias(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("exposureBias"));
    }

    /**
     * Determine if the '<code>exposureMode</code>' attribute was set.
     *
     * @return true if the '<code>exposureMode</code>' attribute was set.
     */
    bool has_exposure_mode() const {
      return Storage().isMember("exposureMode");
    }

    /**
     * Clears the '<code>exposureMode</code>' attribute.
     */
    void clear_exposure_mode() {
      MutableStorage()->removeMember("exposureMode");
    }


    /**
     * Get the value of the '<code>exposureMode</code>' attribute.
     */
    const StringPiece get_exposure_mode() const {
      const Json::Value& v = Storage("exposureMode");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>exposureMode</code>' attribute.
     *
     * The exposure mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_exposure_mode(const StringPiece& value) {
      *MutableStorage("exposureMode") = value.data();
    }

    /**
     * Determine if the '<code>exposureTime</code>' attribute was set.
     *
     * @return true if the '<code>exposureTime</code>' attribute was set.
     */
    bool has_exposure_time() const {
      return Storage().isMember("exposureTime");
    }

    /**
     * Clears the '<code>exposureTime</code>' attribute.
     */
    void clear_exposure_time() {
      MutableStorage()->removeMember("exposureTime");
    }


    /**
     * Get the value of the '<code>exposureTime</code>' attribute.
     */
    float get_exposure_time() const {
      const Json::Value& storage = Storage("exposureTime");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>exposureTime</code>' attribute.
     *
     * The length of the exposure, in seconds.
     *
     * @param[in] value The new value.
     */
    void set_exposure_time(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("exposureTime"));
    }

    /**
     * Determine if the '<code>flashUsed</code>' attribute was set.
     *
     * @return true if the '<code>flashUsed</code>' attribute was set.
     */
    bool has_flash_used() const {
      return Storage().isMember("flashUsed");
    }

    /**
     * Clears the '<code>flashUsed</code>' attribute.
     */
    void clear_flash_used() {
      MutableStorage()->removeMember("flashUsed");
    }


    /**
     * Get the value of the '<code>flashUsed</code>' attribute.
     */
    bool get_flash_used() const {
      const Json::Value& storage = Storage("flashUsed");
      return client::JsonValueToCppValueHelper<bool >(storage);
    }

    /**
     * Change the '<code>flashUsed</code>' attribute.
     *
     * Whether a flash was used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_flash_used(bool value) {
      client::SetJsonValueFromCppValueHelper<bool >(
        value, MutableStorage("flashUsed"));
    }

    /**
     * Determine if the '<code>focalLength</code>' attribute was set.
     *
     * @return true if the '<code>focalLength</code>' attribute was set.
     */
    bool has_focal_length() const {
      return Storage().isMember("focalLength");
    }

    /**
     * Clears the '<code>focalLength</code>' attribute.
     */
    void clear_focal_length() {
      MutableStorage()->removeMember("focalLength");
    }


    /**
     * Get the value of the '<code>focalLength</code>' attribute.
     */
    float get_focal_length() const {
      const Json::Value& storage = Storage("focalLength");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>focalLength</code>' attribute.
     *
     * The focal length used to create the photo, in millimeters.
     *
     * @param[in] value The new value.
     */
    void set_focal_length(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("focalLength"));
    }

    /**
     * Determine if the '<code>height</code>' attribute was set.
     *
     * @return true if the '<code>height</code>' attribute was set.
     */
    bool has_height() const {
      return Storage().isMember("height");
    }

    /**
     * Clears the '<code>height</code>' attribute.
     */
    void clear_height() {
      MutableStorage()->removeMember("height");
    }


    /**
     * Get the value of the '<code>height</code>' attribute.
     */
    int32 get_height() const {
      const Json::Value& storage = Storage("height");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>height</code>' attribute.
     *
     * The height of the image in pixels.
     *
     * @param[in] value The new value.
     */
    void set_height(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("height"));
    }

    /**
     * Determine if the '<code>isoSpeed</code>' attribute was set.
     *
     * @return true if the '<code>isoSpeed</code>' attribute was set.
     */
    bool has_iso_speed() const {
      return Storage().isMember("isoSpeed");
    }

    /**
     * Clears the '<code>isoSpeed</code>' attribute.
     */
    void clear_iso_speed() {
      MutableStorage()->removeMember("isoSpeed");
    }


    /**
     * Get the value of the '<code>isoSpeed</code>' attribute.
     */
    int32 get_iso_speed() const {
      const Json::Value& storage = Storage("isoSpeed");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>isoSpeed</code>' attribute.
     *
     * The ISO speed used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_iso_speed(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("isoSpeed"));
    }

    /**
     * Determine if the '<code>lens</code>' attribute was set.
     *
     * @return true if the '<code>lens</code>' attribute was set.
     */
    bool has_lens() const {
      return Storage().isMember("lens");
    }

    /**
     * Clears the '<code>lens</code>' attribute.
     */
    void clear_lens() {
      MutableStorage()->removeMember("lens");
    }


    /**
     * Get the value of the '<code>lens</code>' attribute.
     */
    const StringPiece get_lens() const {
      const Json::Value& v = Storage("lens");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>lens</code>' attribute.
     *
     * The lens used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_lens(const StringPiece& value) {
      *MutableStorage("lens") = value.data();
    }

    /**
     * Determine if the '<code>location</code>' attribute was set.
     *
     * @return true if the '<code>location</code>' attribute was set.
     */
    bool has_location() const {
      return Storage().isMember("location");
    }

    /**
     * Clears the '<code>location</code>' attribute.
     */
    void clear_location() {
      MutableStorage()->removeMember("location");
    }


    /**
     * Get a reference to the value of the '<code>location</code>' attribute.
     */
    const FileImageMediaMetadataLocation get_location() const {
       const Json::Value& storage = Storage("location");
      return client::JsonValueToCppValueHelper<FileImageMediaMetadataLocation >(storage);
    }

    /**
     * Gets a reference to a mutable value of the '<code>location</code>'
     * property.
     *
     * Geographic location information stored in the image.
     *
     * @return The result can be modified to change the attribute value.
     */
    FileImageMediaMetadataLocation mutable_location() {
      Json::Value* storage = MutableStorage("location");
      return client::JsonValueToMutableCppValueHelper<FileImageMediaMetadataLocation >(storage);
    }

    /**
     * Determine if the '<code>maxApertureValue</code>' attribute was set.
     *
     * @return true if the '<code>maxApertureValue</code>' attribute was set.
     */
    bool has_max_aperture_value() const {
      return Storage().isMember("maxApertureValue");
    }

    /**
     * Clears the '<code>maxApertureValue</code>' attribute.
     */
    void clear_max_aperture_value() {
      MutableStorage()->removeMember("maxApertureValue");
    }


    /**
     * Get the value of the '<code>maxApertureValue</code>' attribute.
     */
    float get_max_aperture_value() const {
      const Json::Value& storage = Storage("maxApertureValue");
      return client::JsonValueToCppValueHelper<float >(storage);
    }

    /**
     * Change the '<code>maxApertureValue</code>' attribute.
     *
     * The smallest f-number of the lens at the focal length used to create the
     * photo (APEX value).
     *
     * @param[in] value The new value.
     */
    void set_max_aperture_value(float value) {
      client::SetJsonValueFromCppValueHelper<float >(
        value, MutableStorage("maxApertureValue"));
    }

    /**
     * Determine if the '<code>meteringMode</code>' attribute was set.
     *
     * @return true if the '<code>meteringMode</code>' attribute was set.
     */
    bool has_metering_mode() const {
      return Storage().isMember("meteringMode");
    }

    /**
     * Clears the '<code>meteringMode</code>' attribute.
     */
    void clear_metering_mode() {
      MutableStorage()->removeMember("meteringMode");
    }


    /**
     * Get the value of the '<code>meteringMode</code>' attribute.
     */
    const StringPiece get_metering_mode() const {
      const Json::Value& v = Storage("meteringMode");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>meteringMode</code>' attribute.
     *
     * The metering mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_metering_mode(const StringPiece& value) {
      *MutableStorage("meteringMode") = value.data();
    }

    /**
     * Determine if the '<code>rotation</code>' attribute was set.
     *
     * @return true if the '<code>rotation</code>' attribute was set.
     */
    bool has_rotation() const {
      return Storage().isMember("rotation");
    }

    /**
     * Clears the '<code>rotation</code>' attribute.
     */
    void clear_rotation() {
      MutableStorage()->removeMember("rotation");
    }


    /**
     * Get the value of the '<code>rotation</code>' attribute.
     */
    int32 get_rotation() const {
      const Json::Value& storage = Storage("rotation");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>rotation</code>' attribute.
     *
     * The rotation in clockwise degrees from the image's original orientation.
     *
     * @param[in] value The new value.
     */
    void set_rotation(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("rotation"));
    }

    /**
     * Determine if the '<code>sensor</code>' attribute was set.
     *
     * @return true if the '<code>sensor</code>' attribute was set.
     */
    bool has_sensor() const {
      return Storage().isMember("sensor");
    }

    /**
     * Clears the '<code>sensor</code>' attribute.
     */
    void clear_sensor() {
      MutableStorage()->removeMember("sensor");
    }


    /**
     * Get the value of the '<code>sensor</code>' attribute.
     */
    const StringPiece get_sensor() const {
      const Json::Value& v = Storage("sensor");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>sensor</code>' attribute.
     *
     * The type of sensor used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_sensor(const StringPiece& value) {
      *MutableStorage("sensor") = value.data();
    }

    /**
     * Determine if the '<code>subjectDistance</code>' attribute was set.
     *
     * @return true if the '<code>subjectDistance</code>' attribute was set.
     */
    bool has_subject_distance() const {
      return Storage().isMember("subjectDistance");
    }

    /**
     * Clears the '<code>subjectDistance</code>' attribute.
     */
    void clear_subject_distance() {
      MutableStorage()->removeMember("subjectDistance");
    }


    /**
     * Get the value of the '<code>subjectDistance</code>' attribute.
     */
    int32 get_subject_distance() const {
      const Json::Value& storage = Storage("subjectDistance");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>subjectDistance</code>' attribute.
     *
     * The distance to the subject of the photo, in meters.
     *
     * @param[in] value The new value.
     */
    void set_subject_distance(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("subjectDistance"));
    }

    /**
     * Determine if the '<code>time</code>' attribute was set.
     *
     * @return true if the '<code>time</code>' attribute was set.
     */
    bool has_time() const {
      return Storage().isMember("time");
    }

    /**
     * Clears the '<code>time</code>' attribute.
     */
    void clear_time() {
      MutableStorage()->removeMember("time");
    }


    /**
     * Get the value of the '<code>time</code>' attribute.
     */
    const StringPiece get_time() const {
      const Json::Value& v = Storage("time");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>time</code>' attribute.
     *
     * The date and time the photo was taken (EXIF DateTime).
     *
     * @param[in] value The new value.
     */
    void set_time(const StringPiece& value) {
      *MutableStorage("time") = value.data();
    }

    /**
     * Determine if the '<code>whiteBalance</code>' attribute was set.
     *
     * @return true if the '<code>whiteBalance</code>' attribute was set.
     */
    bool has_white_balance() const {
      return Storage().isMember("whiteBalance");
    }

    /**
     * Clears the '<code>whiteBalance</code>' attribute.
     */
    void clear_white_balance() {
      MutableStorage()->removeMember("whiteBalance");
    }


    /**
     * Get the value of the '<code>whiteBalance</code>' attribute.
     */
    const StringPiece get_white_balance() const {
      const Json::Value& v = Storage("whiteBalance");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>whiteBalance</code>' attribute.
     *
     * The white balance mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_white_balance(const StringPiece& value) {
      *MutableStorage("whiteBalance") = value.data();
    }

    /**
     * Determine if the '<code>width</code>' attribute was set.
     *
     * @return true if the '<code>width</code>' attribute was set.
     */
    bool has_width() const {
      return Storage().isMember("width");
    }

    /**
     * Clears the '<code>width</code>' attribute.
     */
    void clear_width() {
      MutableStorage()->removeMember("width");
    }


    /**
     * Get the value of the '<code>width</code>' attribute.
     */
    int32 get_width() const {
      const Json::Value& storage = Storage("width");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>width</code>' attribute.
     *
     * The width of the image in pixels.
     *
     * @param[in] value The new value.
     */
    void set_width(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("width"));
    }

   private:
    void operator=(const FileImageMediaMetadata&);
  };  // FileImageMediaMetadata
  /**
   * Additional metadata about video media. This may not be available
   * immediately upon upload.
   *
   * @ingroup DataObject
   */
  class FileVideoMediaMetadata : public client::JsonCppData {
   public:
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileVideoMediaMetadata* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileVideoMediaMetadata(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileVideoMediaMetadata(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileVideoMediaMetadata();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileVideoMediaMetadata</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileVideoMediaMetadata");
    }

    /**
     * Determine if the '<code>durationMillis</code>' attribute was set.
     *
     * @return true if the '<code>durationMillis</code>' attribute was set.
     */
    bool has_duration_millis() const {
      return Storage().isMember("durationMillis");
    }

    /**
     * Clears the '<code>durationMillis</code>' attribute.
     */
    void clear_duration_millis() {
      MutableStorage()->removeMember("durationMillis");
    }


    /**
     * Get the value of the '<code>durationMillis</code>' attribute.
     */
    int64 get_duration_millis() const {
      const Json::Value& storage = Storage("durationMillis");
      return client::JsonValueToCppValueHelper<int64 >(storage);
    }

    /**
     * Change the '<code>durationMillis</code>' attribute.
     *
     * The duration of the video in milliseconds.
     *
     * @param[in] value The new value.
     */
    void set_duration_millis(int64 value) {
      client::SetJsonValueFromCppValueHelper<int64 >(
        value, MutableStorage("durationMillis"));
    }

    /**
     * Determine if the '<code>height</code>' attribute was set.
     *
     * @return true if the '<code>height</code>' attribute was set.
     */
    bool has_height() const {
      return Storage().isMember("height");
    }

    /**
     * Clears the '<code>height</code>' attribute.
     */
    void clear_height() {
      MutableStorage()->removeMember("height");
    }


    /**
     * Get the value of the '<code>height</code>' attribute.
     */
    int32 get_height() const {
      const Json::Value& storage = Storage("height");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>height</code>' attribute.
     *
     * The height of the video in pixels.
     *
     * @param[in] value The new value.
     */
    void set_height(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("height"));
    }

    /**
     * Determine if the '<code>width</code>' attribute was set.
     *
     * @return true if the '<code>width</code>' attribute was set.
     */
    bool has_width() const {
      return Storage().isMember("width");
    }

    /**
     * Clears the '<code>width</code>' attribute.
     */
    void clear_width() {
      MutableStorage()->removeMember("width");
    }


    /**
     * Get the value of the '<code>width</code>' attribute.
     */
    int32 get_width() const {
      const Json::Value& storage = Storage("width");
      return client::JsonValueToCppValueHelper<int32 >(storage);
    }

    /**
     * Change the '<code>width</code>' attribute.
     *
     * The width of the video in pixels.
     *
     * @param[in] value The new value.
     */
    void set_width(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32 >(
        value, MutableStorage("width"));
    }

   private:
    void operator=(const FileVideoMediaMetadata&);
  };  // FileVideoMediaMetadata
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static File* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit File(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit File(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~File();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_drive_api::File</code>
   */
  const StringPiece GetTypeName() const {
    return StringPiece("google_drive_api::File");
  }

  /**
   * Determine if the '<code>appProperties</code>' attribute was set.
   *
   * @return true if the '<code>appProperties</code>' attribute was set.
   */
  bool has_app_properties() const {
    return Storage().isMember("appProperties");
  }

  /**
   * Clears the '<code>appProperties</code>' attribute.
   */
  void clear_app_properties() {
    MutableStorage()->removeMember("appProperties");
  }


  /**
   * Get a reference to the value of the '<code>appProperties</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_app_properties() const {
     const Json::Value& storage = Storage("appProperties");
    return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>appProperties</code>'
   * property.
   *
   * A collection of arbitrary key-value pairs which are private to the
   * requesting app.
   * Entries with null values are cleared in update and copy requests.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_appProperties() {
    Json::Value* storage = MutableStorage("appProperties");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Determine if the '<code>capabilities</code>' attribute was set.
   *
   * @return true if the '<code>capabilities</code>' attribute was set.
   */
  bool has_capabilities() const {
    return Storage().isMember("capabilities");
  }

  /**
   * Clears the '<code>capabilities</code>' attribute.
   */
  void clear_capabilities() {
    MutableStorage()->removeMember("capabilities");
  }


  /**
   * Get a reference to the value of the '<code>capabilities</code>' attribute.
   */
  const FileCapabilities get_capabilities() const {
     const Json::Value& storage = Storage("capabilities");
    return client::JsonValueToCppValueHelper<FileCapabilities >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>capabilities</code>'
   * property.
   *
   * Capabilities the current user has on the file.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileCapabilities mutable_capabilities() {
    Json::Value* storage = MutableStorage("capabilities");
    return client::JsonValueToMutableCppValueHelper<FileCapabilities >(storage);
  }

  /**
   * Determine if the '<code>contentHints</code>' attribute was set.
   *
   * @return true if the '<code>contentHints</code>' attribute was set.
   */
  bool has_content_hints() const {
    return Storage().isMember("contentHints");
  }

  /**
   * Clears the '<code>contentHints</code>' attribute.
   */
  void clear_content_hints() {
    MutableStorage()->removeMember("contentHints");
  }


  /**
   * Get a reference to the value of the '<code>contentHints</code>' attribute.
   */
  const FileContentHints get_content_hints() const {
     const Json::Value& storage = Storage("contentHints");
    return client::JsonValueToCppValueHelper<FileContentHints >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>contentHints</code>'
   * property.
   *
   * Additional information about the content of the file. These fields are
   * never populated in responses.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileContentHints mutable_contentHints() {
    Json::Value* storage = MutableStorage("contentHints");
    return client::JsonValueToMutableCppValueHelper<FileContentHints >(storage);
  }

  /**
   * Determine if the '<code>createdTime</code>' attribute was set.
   *
   * @return true if the '<code>createdTime</code>' attribute was set.
   */
  bool has_created_time() const {
    return Storage().isMember("createdTime");
  }

  /**
   * Clears the '<code>createdTime</code>' attribute.
   */
  void clear_created_time() {
    MutableStorage()->removeMember("createdTime");
  }


  /**
   * Get the value of the '<code>createdTime</code>' attribute.
   */
  client::DateTime get_created_time() const {
    const Json::Value& storage = Storage("createdTime");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>createdTime</code>' attribute.
   *
   * The time at which the file was created (RFC 3339 date-time).
   *
   * @param[in] value The new value.
   */
  void set_created_time(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("createdTime"));
  }

  /**
   * Determine if the '<code>description</code>' attribute was set.
   *
   * @return true if the '<code>description</code>' attribute was set.
   */
  bool has_description() const {
    return Storage().isMember("description");
  }

  /**
   * Clears the '<code>description</code>' attribute.
   */
  void clear_description() {
    MutableStorage()->removeMember("description");
  }


  /**
   * Get the value of the '<code>description</code>' attribute.
   */
  const StringPiece get_description() const {
    const Json::Value& v = Storage("description");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>description</code>' attribute.
   *
   * A short description of the file.
   *
   * @param[in] value The new value.
   */
  void set_description(const StringPiece& value) {
    *MutableStorage("description") = value.data();
  }

  /**
   * Determine if the '<code>explicitlyTrashed</code>' attribute was set.
   *
   * @return true if the '<code>explicitlyTrashed</code>' attribute was set.
   */
  bool has_explicitly_trashed() const {
    return Storage().isMember("explicitlyTrashed");
  }

  /**
   * Clears the '<code>explicitlyTrashed</code>' attribute.
   */
  void clear_explicitly_trashed() {
    MutableStorage()->removeMember("explicitlyTrashed");
  }


  /**
   * Get the value of the '<code>explicitlyTrashed</code>' attribute.
   */
  bool get_explicitly_trashed() const {
    const Json::Value& storage = Storage("explicitlyTrashed");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>explicitlyTrashed</code>' attribute.
   *
   * Whether the file has been explicitly trashed, as opposed to recursively
   * trashed from a parent folder.
   *
   * @param[in] value The new value.
   */
  void set_explicitly_trashed(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("explicitlyTrashed"));
  }

  /**
   * Determine if the '<code>fileExtension</code>' attribute was set.
   *
   * @return true if the '<code>fileExtension</code>' attribute was set.
   */
  bool has_file_extension() const {
    return Storage().isMember("fileExtension");
  }

  /**
   * Clears the '<code>fileExtension</code>' attribute.
   */
  void clear_file_extension() {
    MutableStorage()->removeMember("fileExtension");
  }


  /**
   * Get the value of the '<code>fileExtension</code>' attribute.
   */
  const StringPiece get_file_extension() const {
    const Json::Value& v = Storage("fileExtension");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>fileExtension</code>' attribute.
   *
   * The final component of fullFileExtension. This is only available for files
   * with binary content in Drive.
   *
   * @param[in] value The new value.
   */
  void set_file_extension(const StringPiece& value) {
    *MutableStorage("fileExtension") = value.data();
  }

  /**
   * Determine if the '<code>folderColorRgb</code>' attribute was set.
   *
   * @return true if the '<code>folderColorRgb</code>' attribute was set.
   */
  bool has_folder_color_rgb() const {
    return Storage().isMember("folderColorRgb");
  }

  /**
   * Clears the '<code>folderColorRgb</code>' attribute.
   */
  void clear_folder_color_rgb() {
    MutableStorage()->removeMember("folderColorRgb");
  }


  /**
   * Get the value of the '<code>folderColorRgb</code>' attribute.
   */
  const StringPiece get_folder_color_rgb() const {
    const Json::Value& v = Storage("folderColorRgb");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>folderColorRgb</code>' attribute.
   *
   * The color for a folder as an RGB hex string. The supported colors are
   * published in the folderColorPalette field of the About resource.
   * If an unsupported color is specified, the closest color in the palette will
   * be used instead.
   *
   * @param[in] value The new value.
   */
  void set_folder_color_rgb(const StringPiece& value) {
    *MutableStorage("folderColorRgb") = value.data();
  }

  /**
   * Determine if the '<code>fullFileExtension</code>' attribute was set.
   *
   * @return true if the '<code>fullFileExtension</code>' attribute was set.
   */
  bool has_full_file_extension() const {
    return Storage().isMember("fullFileExtension");
  }

  /**
   * Clears the '<code>fullFileExtension</code>' attribute.
   */
  void clear_full_file_extension() {
    MutableStorage()->removeMember("fullFileExtension");
  }


  /**
   * Get the value of the '<code>fullFileExtension</code>' attribute.
   */
  const StringPiece get_full_file_extension() const {
    const Json::Value& v = Storage("fullFileExtension");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>fullFileExtension</code>' attribute.
   *
   * The full file extension extracted from the name field. May contain multiple
   * concatenated extensions, such as "tar.gz". This is only available for files
   * with binary content in Drive.
   * This is automatically updated when the name field changes, however it is
   * not cleared if the new name does not contain a valid extension.
   *
   * @param[in] value The new value.
   */
  void set_full_file_extension(const StringPiece& value) {
    *MutableStorage("fullFileExtension") = value.data();
  }

  /**
   * Determine if the '<code>headRevisionId</code>' attribute was set.
   *
   * @return true if the '<code>headRevisionId</code>' attribute was set.
   */
  bool has_head_revision_id() const {
    return Storage().isMember("headRevisionId");
  }

  /**
   * Clears the '<code>headRevisionId</code>' attribute.
   */
  void clear_head_revision_id() {
    MutableStorage()->removeMember("headRevisionId");
  }


  /**
   * Get the value of the '<code>headRevisionId</code>' attribute.
   */
  const StringPiece get_head_revision_id() const {
    const Json::Value& v = Storage("headRevisionId");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>headRevisionId</code>' attribute.
   *
   * The ID of the file's head revision. This is currently only available for
   * files with binary content in Drive.
   *
   * @param[in] value The new value.
   */
  void set_head_revision_id(const StringPiece& value) {
    *MutableStorage("headRevisionId") = value.data();
  }

  /**
   * Determine if the '<code>iconLink</code>' attribute was set.
   *
   * @return true if the '<code>iconLink</code>' attribute was set.
   */
  bool has_icon_link() const {
    return Storage().isMember("iconLink");
  }

  /**
   * Clears the '<code>iconLink</code>' attribute.
   */
  void clear_icon_link() {
    MutableStorage()->removeMember("iconLink");
  }


  /**
   * Get the value of the '<code>iconLink</code>' attribute.
   */
  const StringPiece get_icon_link() const {
    const Json::Value& v = Storage("iconLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>iconLink</code>' attribute.
   *
   * A static, unauthenticated link to the file's icon.
   *
   * @param[in] value The new value.
   */
  void set_icon_link(const StringPiece& value) {
    *MutableStorage("iconLink") = value.data();
  }

  /**
   * Determine if the '<code>id</code>' attribute was set.
   *
   * @return true if the '<code>id</code>' attribute was set.
   */
  bool has_id() const {
    return Storage().isMember("id");
  }

  /**
   * Clears the '<code>id</code>' attribute.
   */
  void clear_id() {
    MutableStorage()->removeMember("id");
  }


  /**
   * Get the value of the '<code>id</code>' attribute.
   */
  const StringPiece get_id() const {
    const Json::Value& v = Storage("id");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>id</code>' attribute.
   *
   * The ID of the file.
   *
   * @param[in] value The new value.
   */
  void set_id(const StringPiece& value) {
    *MutableStorage("id") = value.data();
  }

  /**
   * Determine if the '<code>imageMediaMetadata</code>' attribute was set.
   *
   * @return true if the '<code>imageMediaMetadata</code>' attribute was set.
   */
  bool has_image_media_metadata() const {
    return Storage().isMember("imageMediaMetadata");
  }

  /**
   * Clears the '<code>imageMediaMetadata</code>' attribute.
   */
  void clear_image_media_metadata() {
    MutableStorage()->removeMember("imageMediaMetadata");
  }


  /**
   * Get a reference to the value of the '<code>imageMediaMetadata</code>'
   * attribute.
   */
  const FileImageMediaMetadata get_image_media_metadata() const {
     const Json::Value& storage = Storage("imageMediaMetadata");
    return client::JsonValueToCppValueHelper<FileImageMediaMetadata >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>imageMediaMetadata</code>' property.
   *
   * Additional metadata about image media, if available.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileImageMediaMetadata mutable_imageMediaMetadata() {
    Json::Value* storage = MutableStorage("imageMediaMetadata");
    return client::JsonValueToMutableCppValueHelper<FileImageMediaMetadata >(storage);
  }

  /**
   * Determine if the '<code>isAppAuthorized</code>' attribute was set.
   *
   * @return true if the '<code>isAppAuthorized</code>' attribute was set.
   */
  bool has_is_app_authorized() const {
    return Storage().isMember("isAppAuthorized");
  }

  /**
   * Clears the '<code>isAppAuthorized</code>' attribute.
   */
  void clear_is_app_authorized() {
    MutableStorage()->removeMember("isAppAuthorized");
  }


  /**
   * Get the value of the '<code>isAppAuthorized</code>' attribute.
   */
  bool get_is_app_authorized() const {
    const Json::Value& storage = Storage("isAppAuthorized");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>isAppAuthorized</code>' attribute.
   *
   * Whether the file was created or opened by the requesting app.
   *
   * @param[in] value The new value.
   */
  void set_is_app_authorized(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("isAppAuthorized"));
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * This is always drive#file.
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>lastModifyingUser</code>' attribute was set.
   *
   * @return true if the '<code>lastModifyingUser</code>' attribute was set.
   */
  bool has_last_modifying_user() const {
    return Storage().isMember("lastModifyingUser");
  }

  /**
   * Clears the '<code>lastModifyingUser</code>' attribute.
   */
  void clear_last_modifying_user() {
    MutableStorage()->removeMember("lastModifyingUser");
  }


  /**
   * Get a reference to the value of the '<code>lastModifyingUser</code>'
   * attribute.
   */
  const User get_last_modifying_user() const;

  /**
   * Gets a reference to a mutable value of the '<code>lastModifyingUser</code>'
   * property.
   *
   * The last user to modify the file.
   *
   * @return The result can be modified to change the attribute value.
   */
  User mutable_lastModifyingUser();

  /**
   * Determine if the '<code>md5Checksum</code>' attribute was set.
   *
   * @return true if the '<code>md5Checksum</code>' attribute was set.
   */
  bool has_md5_checksum() const {
    return Storage().isMember("md5Checksum");
  }

  /**
   * Clears the '<code>md5Checksum</code>' attribute.
   */
  void clear_md5_checksum() {
    MutableStorage()->removeMember("md5Checksum");
  }


  /**
   * Get the value of the '<code>md5Checksum</code>' attribute.
   */
  const StringPiece get_md5_checksum() const {
    const Json::Value& v = Storage("md5Checksum");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>md5Checksum</code>' attribute.
   *
   * The MD5 checksum for the content of the file. This is only applicable to
   * files with binary content in Drive.
   *
   * @param[in] value The new value.
   */
  void set_md5_checksum(const StringPiece& value) {
    *MutableStorage("md5Checksum") = value.data();
  }

  /**
   * Determine if the '<code>mimeType</code>' attribute was set.
   *
   * @return true if the '<code>mimeType</code>' attribute was set.
   */
  bool has_mime_type() const {
    return Storage().isMember("mimeType");
  }

  /**
   * Clears the '<code>mimeType</code>' attribute.
   */
  void clear_mime_type() {
    MutableStorage()->removeMember("mimeType");
  }


  /**
   * Get the value of the '<code>mimeType</code>' attribute.
   */
  const StringPiece get_mime_type() const {
    const Json::Value& v = Storage("mimeType");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>mimeType</code>' attribute.
   *
   * The MIME type of the file.
   * Drive will attempt to automatically detect an appropriate value from
   * uploaded content if no value is provided. The value cannot be changed
   * unless a new revision is uploaded.
   * If a file is created with a Google Doc MIME type, the uploaded content will
   * be imported if possible. The supported import formats are published in the
   * About resource.
   *
   * @param[in] value The new value.
   */
  void set_mime_type(const StringPiece& value) {
    *MutableStorage("mimeType") = value.data();
  }

  /**
   * Determine if the '<code>modifiedByMeTime</code>' attribute was set.
   *
   * @return true if the '<code>modifiedByMeTime</code>' attribute was set.
   */
  bool has_modified_by_me_time() const {
    return Storage().isMember("modifiedByMeTime");
  }

  /**
   * Clears the '<code>modifiedByMeTime</code>' attribute.
   */
  void clear_modified_by_me_time() {
    MutableStorage()->removeMember("modifiedByMeTime");
  }


  /**
   * Get the value of the '<code>modifiedByMeTime</code>' attribute.
   */
  client::DateTime get_modified_by_me_time() const {
    const Json::Value& storage = Storage("modifiedByMeTime");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>modifiedByMeTime</code>' attribute.
   *
   * The last time the file was modified by the user (RFC 3339 date-time).
   *
   * @param[in] value The new value.
   */
  void set_modified_by_me_time(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("modifiedByMeTime"));
  }

  /**
   * Determine if the '<code>modifiedTime</code>' attribute was set.
   *
   * @return true if the '<code>modifiedTime</code>' attribute was set.
   */
  bool has_modified_time() const {
    return Storage().isMember("modifiedTime");
  }

  /**
   * Clears the '<code>modifiedTime</code>' attribute.
   */
  void clear_modified_time() {
    MutableStorage()->removeMember("modifiedTime");
  }


  /**
   * Get the value of the '<code>modifiedTime</code>' attribute.
   */
  client::DateTime get_modified_time() const {
    const Json::Value& storage = Storage("modifiedTime");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>modifiedTime</code>' attribute.
   *
   * The last time the file was modified by anyone (RFC 3339 date-time).
   * Note that setting modifiedTime will also update modifiedByMeTime for the
   * user.
   *
   * @param[in] value The new value.
   */
  void set_modified_time(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("modifiedTime"));
  }

  /**
   * Determine if the '<code>name</code>' attribute was set.
   *
   * @return true if the '<code>name</code>' attribute was set.
   */
  bool has_name() const {
    return Storage().isMember("name");
  }

  /**
   * Clears the '<code>name</code>' attribute.
   */
  void clear_name() {
    MutableStorage()->removeMember("name");
  }


  /**
   * Get the value of the '<code>name</code>' attribute.
   */
  const StringPiece get_name() const {
    const Json::Value& v = Storage("name");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>name</code>' attribute.
   *
   * The name of the file. This is not necessarily unique within a folder.
   *
   * @param[in] value The new value.
   */
  void set_name(const StringPiece& value) {
    *MutableStorage("name") = value.data();
  }

  /**
   * Determine if the '<code>originalFilename</code>' attribute was set.
   *
   * @return true if the '<code>originalFilename</code>' attribute was set.
   */
  bool has_original_filename() const {
    return Storage().isMember("originalFilename");
  }

  /**
   * Clears the '<code>originalFilename</code>' attribute.
   */
  void clear_original_filename() {
    MutableStorage()->removeMember("originalFilename");
  }


  /**
   * Get the value of the '<code>originalFilename</code>' attribute.
   */
  const StringPiece get_original_filename() const {
    const Json::Value& v = Storage("originalFilename");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>originalFilename</code>' attribute.
   *
   * The original filename of the uploaded content if available, or else the
   * original value of the name field. This is only available for files with
   * binary content in Drive.
   *
   * @param[in] value The new value.
   */
  void set_original_filename(const StringPiece& value) {
    *MutableStorage("originalFilename") = value.data();
  }

  /**
   * Determine if the '<code>ownedByMe</code>' attribute was set.
   *
   * @return true if the '<code>ownedByMe</code>' attribute was set.
   */
  bool has_owned_by_me() const {
    return Storage().isMember("ownedByMe");
  }

  /**
   * Clears the '<code>ownedByMe</code>' attribute.
   */
  void clear_owned_by_me() {
    MutableStorage()->removeMember("ownedByMe");
  }


  /**
   * Get the value of the '<code>ownedByMe</code>' attribute.
   */
  bool get_owned_by_me() const {
    const Json::Value& storage = Storage("ownedByMe");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>ownedByMe</code>' attribute.
   *
   * Whether the user owns the file.
   *
   * @param[in] value The new value.
   */
  void set_owned_by_me(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("ownedByMe"));
  }

  /**
   * Determine if the '<code>owners</code>' attribute was set.
   *
   * @return true if the '<code>owners</code>' attribute was set.
   */
  bool has_owners() const {
    return Storage().isMember("owners");
  }

  /**
   * Clears the '<code>owners</code>' attribute.
   */
  void clear_owners() {
    MutableStorage()->removeMember("owners");
  }


  /**
   * Get a reference to the value of the '<code>owners</code>' attribute.
   */
  const client::JsonCppArray<User > get_owners() const;

  /**
   * Gets a reference to a mutable value of the '<code>owners</code>' property.
   *
   * The owners of the file. Currently, only certain legacy files may have more
   * than one owner.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<User > mutable_owners();

  /**
   * Determine if the '<code>parents</code>' attribute was set.
   *
   * @return true if the '<code>parents</code>' attribute was set.
   */
  bool has_parents() const {
    return Storage().isMember("parents");
  }

  /**
   * Clears the '<code>parents</code>' attribute.
   */
  void clear_parents() {
    MutableStorage()->removeMember("parents");
  }


  /**
   * Get a reference to the value of the '<code>parents</code>' attribute.
   */
  const client::JsonCppArray<string > get_parents() const {
     const Json::Value& storage = Storage("parents");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>parents</code>' property.
   *
   * The IDs of the parent folders which contain the file.
   * If not specified as part of a create request, the file will be placed
   * directly in the My Drive folder. Update requests must use the addParents
   * and removeParents parameters to modify the values.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_parents() {
    Json::Value* storage = MutableStorage("parents");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>permissions</code>' attribute was set.
   *
   * @return true if the '<code>permissions</code>' attribute was set.
   */
  bool has_permissions() const {
    return Storage().isMember("permissions");
  }

  /**
   * Clears the '<code>permissions</code>' attribute.
   */
  void clear_permissions() {
    MutableStorage()->removeMember("permissions");
  }


  /**
   * Get a reference to the value of the '<code>permissions</code>' attribute.
   */
  const client::JsonCppArray<Permission > get_permissions() const;

  /**
   * Gets a reference to a mutable value of the '<code>permissions</code>'
   * property.
   *
   * The full list of permissions for the file. This is only available if the
   * requesting user can share the file.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<Permission > mutable_permissions();

  /**
   * Determine if the '<code>properties</code>' attribute was set.
   *
   * @return true if the '<code>properties</code>' attribute was set.
   */
  bool has_properties() const {
    return Storage().isMember("properties");
  }

  /**
   * Clears the '<code>properties</code>' attribute.
   */
  void clear_properties() {
    MutableStorage()->removeMember("properties");
  }


  /**
   * Get a reference to the value of the '<code>properties</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_properties() const {
     const Json::Value& storage = Storage("properties");
    return client::JsonValueToCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>properties</code>'
   * property.
   *
   * A collection of arbitrary key-value pairs which are visible to all apps.
   * Entries with null values are cleared in update and copy requests.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_properties() {
    Json::Value* storage = MutableStorage("properties");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppAssociativeArray<string > >(storage);
  }

  /**
   * Determine if the '<code>quotaBytesUsed</code>' attribute was set.
   *
   * @return true if the '<code>quotaBytesUsed</code>' attribute was set.
   */
  bool has_quota_bytes_used() const {
    return Storage().isMember("quotaBytesUsed");
  }

  /**
   * Clears the '<code>quotaBytesUsed</code>' attribute.
   */
  void clear_quota_bytes_used() {
    MutableStorage()->removeMember("quotaBytesUsed");
  }


  /**
   * Get the value of the '<code>quotaBytesUsed</code>' attribute.
   */
  int64 get_quota_bytes_used() const {
    const Json::Value& storage = Storage("quotaBytesUsed");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>quotaBytesUsed</code>' attribute.
   *
   * The number of storage quota bytes used by the file. This includes the head
   * revision as well as previous revisions with keepForever enabled.
   *
   * @param[in] value The new value.
   */
  void set_quota_bytes_used(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("quotaBytesUsed"));
  }

  /**
   * Determine if the '<code>shared</code>' attribute was set.
   *
   * @return true if the '<code>shared</code>' attribute was set.
   */
  bool has_shared() const {
    return Storage().isMember("shared");
  }

  /**
   * Clears the '<code>shared</code>' attribute.
   */
  void clear_shared() {
    MutableStorage()->removeMember("shared");
  }


  /**
   * Get the value of the '<code>shared</code>' attribute.
   */
  bool get_shared() const {
    const Json::Value& storage = Storage("shared");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>shared</code>' attribute.
   *
   * Whether the file has been shared.
   *
   * @param[in] value The new value.
   */
  void set_shared(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("shared"));
  }

  /**
   * Determine if the '<code>sharedWithMeTime</code>' attribute was set.
   *
   * @return true if the '<code>sharedWithMeTime</code>' attribute was set.
   */
  bool has_shared_with_me_time() const {
    return Storage().isMember("sharedWithMeTime");
  }

  /**
   * Clears the '<code>sharedWithMeTime</code>' attribute.
   */
  void clear_shared_with_me_time() {
    MutableStorage()->removeMember("sharedWithMeTime");
  }


  /**
   * Get the value of the '<code>sharedWithMeTime</code>' attribute.
   */
  client::DateTime get_shared_with_me_time() const {
    const Json::Value& storage = Storage("sharedWithMeTime");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>sharedWithMeTime</code>' attribute.
   *
   * The time at which the file was shared with the user, if applicable (RFC
   * 3339 date-time).
   *
   * @param[in] value The new value.
   */
  void set_shared_with_me_time(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("sharedWithMeTime"));
  }

  /**
   * Determine if the '<code>sharingUser</code>' attribute was set.
   *
   * @return true if the '<code>sharingUser</code>' attribute was set.
   */
  bool has_sharing_user() const {
    return Storage().isMember("sharingUser");
  }

  /**
   * Clears the '<code>sharingUser</code>' attribute.
   */
  void clear_sharing_user() {
    MutableStorage()->removeMember("sharingUser");
  }


  /**
   * Get a reference to the value of the '<code>sharingUser</code>' attribute.
   */
  const User get_sharing_user() const;

  /**
   * Gets a reference to a mutable value of the '<code>sharingUser</code>'
   * property.
   *
   * The user who shared the file with the requesting user, if applicable.
   *
   * @return The result can be modified to change the attribute value.
   */
  User mutable_sharingUser();

  /**
   * Determine if the '<code>size</code>' attribute was set.
   *
   * @return true if the '<code>size</code>' attribute was set.
   */
  bool has_size() const {
    return Storage().isMember("size");
  }

  /**
   * Clears the '<code>size</code>' attribute.
   */
  void clear_size() {
    MutableStorage()->removeMember("size");
  }


  /**
   * Get the value of the '<code>size</code>' attribute.
   */
  int64 get_size() const {
    const Json::Value& storage = Storage("size");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>size</code>' attribute.
   *
   * The size of the file's content in bytes. This is only applicable to files
   * with binary content in Drive.
   *
   * @param[in] value The new value.
   */
  void set_size(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("size"));
  }

  /**
   * Determine if the '<code>spaces</code>' attribute was set.
   *
   * @return true if the '<code>spaces</code>' attribute was set.
   */
  bool has_spaces() const {
    return Storage().isMember("spaces");
  }

  /**
   * Clears the '<code>spaces</code>' attribute.
   */
  void clear_spaces() {
    MutableStorage()->removeMember("spaces");
  }


  /**
   * Get a reference to the value of the '<code>spaces</code>' attribute.
   */
  const client::JsonCppArray<string > get_spaces() const {
     const Json::Value& storage = Storage("spaces");
    return client::JsonValueToCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Gets a reference to a mutable value of the '<code>spaces</code>' property.
   *
   * The list of spaces which contain the file. The currently supported values
   * are 'drive', 'appDataFolder' and 'photos'.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_spaces() {
    Json::Value* storage = MutableStorage("spaces");
    return client::JsonValueToMutableCppValueHelper<client::JsonCppArray<string > >(storage);
  }

  /**
   * Determine if the '<code>starred</code>' attribute was set.
   *
   * @return true if the '<code>starred</code>' attribute was set.
   */
  bool has_starred() const {
    return Storage().isMember("starred");
  }

  /**
   * Clears the '<code>starred</code>' attribute.
   */
  void clear_starred() {
    MutableStorage()->removeMember("starred");
  }


  /**
   * Get the value of the '<code>starred</code>' attribute.
   */
  bool get_starred() const {
    const Json::Value& storage = Storage("starred");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>starred</code>' attribute.
   *
   * Whether the user has starred the file.
   *
   * @param[in] value The new value.
   */
  void set_starred(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("starred"));
  }

  /**
   * Determine if the '<code>thumbnailLink</code>' attribute was set.
   *
   * @return true if the '<code>thumbnailLink</code>' attribute was set.
   */
  bool has_thumbnail_link() const {
    return Storage().isMember("thumbnailLink");
  }

  /**
   * Clears the '<code>thumbnailLink</code>' attribute.
   */
  void clear_thumbnail_link() {
    MutableStorage()->removeMember("thumbnailLink");
  }


  /**
   * Get the value of the '<code>thumbnailLink</code>' attribute.
   */
  const StringPiece get_thumbnail_link() const {
    const Json::Value& v = Storage("thumbnailLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>thumbnailLink</code>' attribute.
   *
   * A short-lived link to the file's thumbnail, if available. Typically lasts
   * on the order of hours.
   *
   * @param[in] value The new value.
   */
  void set_thumbnail_link(const StringPiece& value) {
    *MutableStorage("thumbnailLink") = value.data();
  }

  /**
   * Determine if the '<code>trashed</code>' attribute was set.
   *
   * @return true if the '<code>trashed</code>' attribute was set.
   */
  bool has_trashed() const {
    return Storage().isMember("trashed");
  }

  /**
   * Clears the '<code>trashed</code>' attribute.
   */
  void clear_trashed() {
    MutableStorage()->removeMember("trashed");
  }


  /**
   * Get the value of the '<code>trashed</code>' attribute.
   */
  bool get_trashed() const {
    const Json::Value& storage = Storage("trashed");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>trashed</code>' attribute.
   *
   * Whether the file has been trashed, either explicitly or from a trashed
   * parent folder. Only the owner may trash a file, and other users cannot see
   * files in the owner's trash.
   *
   * @param[in] value The new value.
   */
  void set_trashed(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("trashed"));
  }

  /**
   * Determine if the '<code>version</code>' attribute was set.
   *
   * @return true if the '<code>version</code>' attribute was set.
   */
  bool has_version() const {
    return Storage().isMember("version");
  }

  /**
   * Clears the '<code>version</code>' attribute.
   */
  void clear_version() {
    MutableStorage()->removeMember("version");
  }


  /**
   * Get the value of the '<code>version</code>' attribute.
   */
  int64 get_version() const {
    const Json::Value& storage = Storage("version");
    return client::JsonValueToCppValueHelper<int64 >(storage);
  }

  /**
   * Change the '<code>version</code>' attribute.
   *
   * A monotonically increasing version number for the file. This reflects every
   * change made to the file on the server, even those not visible to the user.
   *
   * @param[in] value The new value.
   */
  void set_version(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64 >(
      value, MutableStorage("version"));
  }

  /**
   * Determine if the '<code>videoMediaMetadata</code>' attribute was set.
   *
   * @return true if the '<code>videoMediaMetadata</code>' attribute was set.
   */
  bool has_video_media_metadata() const {
    return Storage().isMember("videoMediaMetadata");
  }

  /**
   * Clears the '<code>videoMediaMetadata</code>' attribute.
   */
  void clear_video_media_metadata() {
    MutableStorage()->removeMember("videoMediaMetadata");
  }


  /**
   * Get a reference to the value of the '<code>videoMediaMetadata</code>'
   * attribute.
   */
  const FileVideoMediaMetadata get_video_media_metadata() const {
     const Json::Value& storage = Storage("videoMediaMetadata");
    return client::JsonValueToCppValueHelper<FileVideoMediaMetadata >(storage);
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>videoMediaMetadata</code>' property.
   *
   * Additional metadata about video media. This may not be available
   * immediately upon upload.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileVideoMediaMetadata mutable_videoMediaMetadata() {
    Json::Value* storage = MutableStorage("videoMediaMetadata");
    return client::JsonValueToMutableCppValueHelper<FileVideoMediaMetadata >(storage);
  }

  /**
   * Determine if the '<code>viewedByMe</code>' attribute was set.
   *
   * @return true if the '<code>viewedByMe</code>' attribute was set.
   */
  bool has_viewed_by_me() const {
    return Storage().isMember("viewedByMe");
  }

  /**
   * Clears the '<code>viewedByMe</code>' attribute.
   */
  void clear_viewed_by_me() {
    MutableStorage()->removeMember("viewedByMe");
  }


  /**
   * Get the value of the '<code>viewedByMe</code>' attribute.
   */
  bool get_viewed_by_me() const {
    const Json::Value& storage = Storage("viewedByMe");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>viewedByMe</code>' attribute.
   *
   * Whether the file has been viewed by this user.
   *
   * @param[in] value The new value.
   */
  void set_viewed_by_me(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("viewedByMe"));
  }

  /**
   * Determine if the '<code>viewedByMeTime</code>' attribute was set.
   *
   * @return true if the '<code>viewedByMeTime</code>' attribute was set.
   */
  bool has_viewed_by_me_time() const {
    return Storage().isMember("viewedByMeTime");
  }

  /**
   * Clears the '<code>viewedByMeTime</code>' attribute.
   */
  void clear_viewed_by_me_time() {
    MutableStorage()->removeMember("viewedByMeTime");
  }


  /**
   * Get the value of the '<code>viewedByMeTime</code>' attribute.
   */
  client::DateTime get_viewed_by_me_time() const {
    const Json::Value& storage = Storage("viewedByMeTime");
    return client::JsonValueToCppValueHelper<client::DateTime >(storage);
  }

  /**
   * Change the '<code>viewedByMeTime</code>' attribute.
   *
   * The last time the file was viewed by the user (RFC 3339 date-time).
   *
   * @param[in] value The new value.
   */
  void set_viewed_by_me_time(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime >(
      value, MutableStorage("viewedByMeTime"));
  }

  /**
   * Determine if the '<code>viewersCanCopyContent</code>' attribute was set.
   *
   * @return true if the '<code>viewersCanCopyContent</code>' attribute was set.
   */
  bool has_viewers_can_copy_content() const {
    return Storage().isMember("viewersCanCopyContent");
  }

  /**
   * Clears the '<code>viewersCanCopyContent</code>' attribute.
   */
  void clear_viewers_can_copy_content() {
    MutableStorage()->removeMember("viewersCanCopyContent");
  }


  /**
   * Get the value of the '<code>viewersCanCopyContent</code>' attribute.
   */
  bool get_viewers_can_copy_content() const {
    const Json::Value& storage = Storage("viewersCanCopyContent");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>viewersCanCopyContent</code>' attribute.
   *
   * Whether users with only reader or commenter permission can copy the file's
   * content. This affects copy, download, and print operations.
   *
   * @param[in] value The new value.
   */
  void set_viewers_can_copy_content(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("viewersCanCopyContent"));
  }

  /**
   * Determine if the '<code>webContentLink</code>' attribute was set.
   *
   * @return true if the '<code>webContentLink</code>' attribute was set.
   */
  bool has_web_content_link() const {
    return Storage().isMember("webContentLink");
  }

  /**
   * Clears the '<code>webContentLink</code>' attribute.
   */
  void clear_web_content_link() {
    MutableStorage()->removeMember("webContentLink");
  }


  /**
   * Get the value of the '<code>webContentLink</code>' attribute.
   */
  const StringPiece get_web_content_link() const {
    const Json::Value& v = Storage("webContentLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>webContentLink</code>' attribute.
   *
   * A link for downloading the content of the file in a browser. This is only
   * available for files with binary content in Drive.
   *
   * @param[in] value The new value.
   */
  void set_web_content_link(const StringPiece& value) {
    *MutableStorage("webContentLink") = value.data();
  }

  /**
   * Determine if the '<code>webViewLink</code>' attribute was set.
   *
   * @return true if the '<code>webViewLink</code>' attribute was set.
   */
  bool has_web_view_link() const {
    return Storage().isMember("webViewLink");
  }

  /**
   * Clears the '<code>webViewLink</code>' attribute.
   */
  void clear_web_view_link() {
    MutableStorage()->removeMember("webViewLink");
  }


  /**
   * Get the value of the '<code>webViewLink</code>' attribute.
   */
  const StringPiece get_web_view_link() const {
    const Json::Value& v = Storage("webViewLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>webViewLink</code>' attribute.
   *
   * A link for opening the file in a relevant Google editor or viewer in a
   * browser.
   *
   * @param[in] value The new value.
   */
  void set_web_view_link(const StringPiece& value) {
    *MutableStorage("webViewLink") = value.data();
  }

  /**
   * Determine if the '<code>writersCanShare</code>' attribute was set.
   *
   * @return true if the '<code>writersCanShare</code>' attribute was set.
   */
  bool has_writers_can_share() const {
    return Storage().isMember("writersCanShare");
  }

  /**
   * Clears the '<code>writersCanShare</code>' attribute.
   */
  void clear_writers_can_share() {
    MutableStorage()->removeMember("writersCanShare");
  }


  /**
   * Get the value of the '<code>writersCanShare</code>' attribute.
   */
  bool get_writers_can_share() const {
    const Json::Value& storage = Storage("writersCanShare");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>writersCanShare</code>' attribute.
   *
   * Whether users with only writer permission can modify the file's
   * permissions.
   *
   * @param[in] value The new value.
   */
  void set_writers_can_share(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("writersCanShare"));
  }

 private:
  void operator=(const File&);
};  // File
}  // namespace google_drive_api
#endif  // GOOGLE_DRIVE_API_FILE_H_
